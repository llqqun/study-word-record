# 事件循环

核心关键词: 渲染主线程, 宏任务, 微任务, WebAPI, 异步

* 浏览器渲染主线程无限循环执行
* 检查事件队列是否有任务,按顺序执行队列中的任务,如果队列中没有任务,则进入休眠状态
* 其它线程向(浏览器微博WebAPI)队列末尾添加新任务,如果主线程是休眠状态,则将其唤醒

> 面试题: 什么是JS 异步?  
> js是单线程的,它是运行在渲染主线程中的(渲染主线程只有一个)
> 如果任务都是同步执行的,在执行耗时很长的任务时,会阻塞后面的任务的执行  
> 为了解决因任务阻塞造成的页面更新影响,不给用户页面卡死的现象  
> 浏览器采用异步的方式来避免,当异步任务执行时(计时器,网络请求,事件监听...),主线程将任务交给浏览器其它线程去
> 当前任务则立即完成,转而执行后续代码.当其它线程任务完成时,将之前异步任务传递的回调函数包装成任务放入
> 事件队列末尾,等待主线程调用,在这种异步模式下,浏览器永不阻塞,从而最大限度的保障了单线程的流程运行

 js为什么会阻塞渲染

```js
// 死循环指定时间函数
function delay(time) {
    var start = Date.now();
    while (new Date.now() - start < time>) {}
}
delay(3000) // 阻塞渲染主线程3s
```

事件任务没有优先级,但是任务队列有  
以前的js只区分宏任务和微任务队列,新的W3C标准浏进行了细分,各个任务队列的优先级不同  
在一次事件循环中,浏览器可以根据实际情况从不同的队列取出任务执行  
同一个任务类型的任务必须在相同的任务队列  

chrome中目前的队列包括 [延时队列(中), 交互队列(高), 微队列(最高)]

![event-loop](/images/event-loop.webp)  

总结: 简述JS事件循环过程(排除了一些页面更新渲染,dom加载操作)  
1.渲染主线程执行全局js  
2.执行栈中同步执行上下文  
3.当执行到异步任务时,主线程会通知浏览器的对应线程执行,主线程中该异步任务结束,继续往下执行  
4.当其他线程(上面通知的线程)执行完毕,则将回调函数包装成任务添加到任务队列末尾,等待主线程调用  
5.当主线程任务执行完毕,则开始检索任务队列(微任务队列,交互队列,....,根据队列优先级执行顺序也不一样),发现任务则执行,当任务队列都执行完毕后,主线程进入休眠状态  
6.当新的任务被添加到任务队列,则唤醒主线程按上面的顺序循环执行
