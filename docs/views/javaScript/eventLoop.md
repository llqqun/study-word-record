# 事件循环

核心关键词: 渲染主线程, 任务队列, WebAPI, js异步

* 浏览器渲染主线程无限循环执行
* 检查事件队列是否有任务,按顺序执行队列中的任务,如果队列中没有任务,则进入休眠状态
* 其它线程向(浏览器微博WebAPI)队列末尾添加新任务,如果主线程是休眠状态,则将其唤醒

> 面试题: 什么是JS 异步?  
> js是单线程的,它是运行在渲染主线程中的(渲染主线程只有一个)
> 如果任务都是同步执行的,在执行耗时很长的任务时,会阻塞后面的任务的执行  
> 为了解决因任务阻塞造成的页面更新影响,不给用户页面卡死的现象  
> 浏览器采用异步的方式来避免,当异步任务执行时(计时器,网络请求,事件监听...),主线程将任务交给浏览器其它线程去
> 当前任务则立即完成,转而执行后续代码.当其它线程任务完成时,将之前异步任务传递的回调函数包装成任务对象放入
> 事件队列末尾,等待主线程调用,在这种异步模式下,浏览器永不阻塞,从而最大限度的保障了单线程的流程运行

 js为什么会阻塞渲染

```js
// 死循环指定时间函数
function delay(time) {
    var start = Date.now();
    while (Date.now() - start < time) {}
}
delay(3000) // 阻塞渲染主线程3s
```

事件任务没有优先级,但是任务队列有  
以前的js只区分宏任务和微任务队列,新的W3C标准浏进行了细分,各个任务队列的优先级不同  
在一次事件循环中,浏览器可以根据实际情况从不同的队列取出任务执行  
同一个任务类型的任务必须在相同的任务队列  

chrome中目前的队列包括 [延时队列(中), 交互队列(高), 微队列(最高)]

```js
setTimeout(( ()=> { console.log(1)}))
Promise.resolve().then(() => { console.log(2)})
console.log(3)
// 输出3,2,1
```

![event-loop](/images/event-loop.webp)  

总结: 简述JS事件循环过程(排除了一些页面更新渲染,dom加载操作)  
1.渲染主线程执行全局js  
2.执行栈中同步执行上下文  
3.当执行到异步任务时,主线程会通知浏览器的对应线程执行,主线程中该异步任务结束,继续往下执行  
4.当其他线程(上面通知的线程)执行完毕,则将回调函数包装成任务添加到任务队列末尾,等待主线程调用  
5.当主线程任务执行完毕,则开始检索任务队列(微任务队列,交互队列,....,根据队列优先级执行顺序也不一样),发现任务则执行,当任务队列都执行完毕后,主线程进入休眠状态  
6.当新的任务被添加到任务队列,则唤醒主线程按上面的顺序循环执行


堆,栈,webAPIs, 回调队列(微任务队列)


如上图为事件循环示例图（或 JS 运行机制图），流程如下：

step1：主线程读取 JS 代码，此时为同步环境，形成相应的堆和执行栈；

step2: 主线程遇到异步任务，指给对应的异步进程进行处理（WEB API）;

step3: 异步进程处理完毕（Ajax 返回、DOM 事件处罚、Timer 到等），将相应的异步任务推入任务队列(宏任务和微任务)；

step4: 主线程执行完毕，查询任务队列，如果存在任务，则取出一个任务推入主线程处理（先进先出）；

step5: 重复执行 step2、3、4；称为事件循环。

执行的大意：

同步环境执行(step1) -> 事件循环 1(step4) -> 事件循环 2(step4 的重复)…

其中的异步进程有：

a、类似 onclick 等，由浏览器内核的 DOM binding 模块处理，事件触发时，回调函数添加到任务队列中；

b、setTimeout 等，由浏览器内核的 Timer 模块处理，时间到达时，回调函数添加到任务队列中；

c、Ajax，由浏览器内核的 Network 模块处理，网络请求返回后，添加到任务队列中
