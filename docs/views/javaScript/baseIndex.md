# javaScript 学习笔记

[[toc]]

## 基础

### 事件循环

核心关键词: 渲染主线程, 宏任务, 微任务, WebAPI, 异步

* 浏览器渲染主线程无限循环执行
* 检查事件队列是否有任务,按顺序执行队列中的任务,如果队列中没有任务,则进入休眠状态
* 其它线程向(浏览器微博WebAPI)队列末尾添加新任务,如果主线程是休眠状态,则将其唤醒

> 面试题: 什么是JS 异步?  
> js是单线程的,它是运行在渲染主线程中的(渲染主线程只有一个)
> 如果任务都是同步执行的,在执行耗时很长的任务时,会阻塞后面的任务的执行  
> 为了解决因任务阻塞造成的页面更新影响,不给用户页面卡死的现象  
> 浏览器采用异步的方式来避免,当异步任务执行时(计时器,网络请求,事件监听...),主线程将任务交给浏览器其它线程去
> 当前任务则立即完成,转而执行后续代码.当其它线程任务完成时,将之前异步任务传递的回调函数包装成任务放入
> 事件队列末尾,等待主线程调用,在这种异步模式下,浏览器永不阻塞,从而最大限度的保障了单线程的流程运行

 js为什么会阻塞渲染

```js
// 死循环指定时间函数
function delay(time) {
    var start = Date.now();
    while (new Date.now() - start < time>) {}
}
delay(3000) // 阻塞渲染主线程3s
```

事件任务没有优先级,但是任务队列有  
以前的js只区分宏任务和微任务队列,新的W3C标准浏进行了细分,各个任务队列的优先级不同  
在一次事件循环中,浏览器可以根据实际情况从不同的队列取出任务执行  
同一个任务类型的任务必须在相同的任务队列  

chrome中目前的队列包括 [延时队列(中), 交互队列(高), 微队列(最高)]

![event-loop](/images/event-loop.webp)  

总结: 简述JS事件循环过程(排除了一些页面更新渲染,dom加载操作)  
1.渲染主线程执行全局js  
2.执行栈中同步执行上下文  
3.当执行到异步任务时,主线程会通知浏览器的对应线程执行,主线程中该异步任务结束,继续往下执行  
4.当其他线程(上面通知的线程)执行完毕,则将回调函数包装成任务添加到任务队列末尾,等待主线程调用  
5.当主线程任务执行完毕,则开始检索任务队列(微任务队列,交互队列,....,根据队列优先级执行顺序也不一样),发现任务则执行,当任务队列都执行完毕后,主线程进入休眠状态  
6.当新的任务被添加到任务队列,则唤醒主线程按上面的顺序循环执行

### 浏览器渲染原理

浏览器地址栏输入网址,运行`网络线程`获取服务端的HTML文档,生成一个渲染任务,添加进任务队列  
在事件循环机制下,渲染主线程执行任务队列中的渲染任务,开始渲染流程.  

渲染流程:  

1. 解析HTML文档
2. 样式计算
3. 布局
4. 分层
5. 绘制
6. 分块
7. 光栅化
8. 画

#### 解析HTML

为了提高解析效率,开始解析前会启动一个预解析线程,率先下载外部css和js  
当解析到link元素时,若外部css未下载解析完成,主线程不会等待,而是继续后续解析  
原因是外部css下载和解析工作在预解析线程中执行,这就是CSS不会阻塞HTML解析根本原因  
然而当解析到script标签时,正常情况(非正常情况:async,defer)下会停止解析HTML  
等待JS下载完成,并将全局代码执行完成,再继续解析HTML  
(原因:js代码执行过程可能回修改DOM树,所以生成DOM过程必须暂停)

![img](/images/parseHtml.png)

第一步解析完成: 得到DOM树和CSSOM 树

##### CSS样式计算

遍历DOM树,通过样式计算得到一个带有计算样式的DOM树

##### 布局

根据DOM样式,计算出各个节点的大小,位置,生成一个Layout树  
Layout树和DOM树节点不一定一一对应

##### 分层

浏览器获取布局树,经过策略优化进行分层  
分层可以使浏览器的效率得到提升,当某一层改变时,不用去重新绘制整个页面,只用绘制单层就好了
通过css 属性 will-change: 属性; 让浏览器风层

#### 绘制

主线程为分层的每一层生成绘制指令, 渲染主线程工作完成,剩余工作交给合成线程

#### 分块

合成线程将对每个图层进行分块,将其划分成很多小区域

#### 光栅化

合成线程将块信息交给GPU进程,以极高的速度完成光栅化,生成一块块的位图

#### 画

合成线程拿到位图后,生成一个个指引信息  
然后将指引信息提交给GPU进程,由GPU进程进行调用,提交GPU硬件,完成最终屏幕成像

## 中级

### Blob && File

### Promise

Promise 对象用于表示一个异步操作的最终完成（或失败）及其结果值。

一个 Promise 必然处于以下三种状态之一：

* 待定（pending）：初始状态，既没有被兑现，也没有被拒绝。

* 已兑现（fulfilled）：意味着操作成功完成。

* 已拒绝（rejected）：意味着操作失败。

## 高级
