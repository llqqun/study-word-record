
# 浏览器渲染原理

浏览器地址栏输入网址,运行`网络线程`获取服务端的HTML文档,生成一个渲染任务,添加进任务队列  
在事件循环机制下,渲染主线程执行任务队列中的渲染任务,开始渲染流程.  

渲染流程:  

1. 解析HTML文档
2. 样式计算
3. 布局
4. 分层
5. 绘制
6. 分块
7. 光栅化
8. 画

## 解析HTML

为了提高解析效率,开始解析前会启动一个预解析线程,率先下载外部css和js  
当解析到link元素时,若外部css未下载解析完成,主线程不会等待,而是继续后续解析  
原因是外部css下载和解析工作在预解析线程中执行,这就是CSS不会阻塞HTML解析根本原因  
然而当解析到script标签时,正常情况(非正常情况:async,defer)下会停止解析HTML  
等待JS下载完成,并将全局代码执行完成,再继续解析HTML  
(原因:js代码执行过程可能回修改DOM树,所以生成DOM过程必须暂停)

![img](/images/parseHtml.png)

第一步解析完成: 得到DOM树和CSSOM 树

## CSS样式计算

遍历DOM树,通过样式计算得到一个带有计算样式的DOM树

## 布局

根据DOM样式,计算出各个节点的大小,位置,生成一个Layout树  
Layout树和DOM树节点不一定一一对应

## 分层

浏览器获取布局树,经过策略优化进行分层  
分层可以使浏览器的效率得到提升,当某一层改变时,不用去重新绘制整个页面,只用绘制单层就好了
通过css 属性 will-change: 属性; 让浏览器风层

## 绘制

主线程为分层的每一层生成绘制指令, 渲染主线程工作完成,剩余工作交给合成线程

## 分块

合成线程将对每个图层进行分块,将其划分成很多小区域

## 光栅化

合成线程将块信息交给GPU进程,以极高的速度完成光栅化,生成一块块的位图

## 画

合成线程拿到位图后,生成一个个指引信息  
然后将指引信息提交给GPU进程,由GPU进程进行调用,提交GPU硬件,完成最终屏幕成像
